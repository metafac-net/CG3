// <auto-generated />
#region Auto-generated
//--------------------------------------------------------------------------------
// Warning: This file was automatically generated. Changes to this file may
// cause incorrect behavior and will be lost when this file is regenerated.
//
// This file was generated using MetaFac.CG3 tools and user supplied metadata.
//
// To download and install the tool, the .NET CLI command is:
// dotnet tool install --global MetaFac.CG3.CLI
//
// For more information about using this tool, the help command is:
// mfcg3 g2c --help
//--------------------------------------------------------------------------------
#endregion
#nullable enable
using MetaFac.Memory;
using MetaFac.CG3.Runtime;
using MetaFac.CG3.Runtime.ProtobufNet3;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using Generated.Interfaces;

namespace Generated.ProtobufNet3
{


    [ProtoContract, CompatibilityLevel(CompatibilityLevel.Level300)]
    //todo when we support polymorphism
    //    foreach AllDerivedClasses
    //    [ProtoInclude(1000 + ClassTags.BuiltinTypes, typeof(BuiltinTypes))]
    //    endfor
    public sealed partial class BuiltinTypes : IBuiltinTypes, IEquatable<BuiltinTypes>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static BuiltinTypes? CreateFrom(IBuiltinTypes? source)
        {
            if (source is null) return null;
            return new BuiltinTypes(source);
        }

        private const int ClassTag = 1;

        [ProtoMember(1, DataFormat = DataFormat.Default)]
        public Boolean[]? Bools { get; set; }
        [ProtoMember(2, DataFormat = DataFormat.ZigZag)]
        public SByte[]? SBytes { get; set; }
        [ProtoMember(3, DataFormat = DataFormat.Default)]
        public Byte[]? Bytes { get; set; }
        [ProtoMember(4, DataFormat = DataFormat.ZigZag)]
        public Int16[]? Shorts { get; set; }
        [ProtoMember(5, DataFormat = DataFormat.Default)]
        public UInt16[]? UShorts { get; set; }
        [ProtoMember(6, DataFormat = DataFormat.Default)]
        public Char[]? Chars { get; set; }
        [ProtoMember(7, DataFormat = DataFormat.ZigZag)]
        public Int32[]? Ints { get; set; }
        [ProtoMember(8, DataFormat = DataFormat.Default)]
        public UInt32[]? UInts { get; set; }
        [ProtoMember(9, DataFormat = DataFormat.Default)]
        public Single[]? Floats { get; set; }
        [ProtoMember(10, DataFormat = DataFormat.ZigZag)]
        public Int64[]? Longs { get; set; }
        [ProtoMember(11, DataFormat = DataFormat.Default)]
        public UInt64[]? ULongs { get; set; }
        [ProtoMember(12, DataFormat = DataFormat.Default)]
        public Double[]? Doubles { get; set; }
        [ProtoMember(13, DataFormat = DataFormat.Default)]
        public DateTimeData[]? DateTimes { get; set; }
        [ProtoMember(14, DataFormat = DataFormat.Default)]
        public TimeSpan[]? TimeSpans { get; set; }
        [ProtoMember(15, DataFormat = DataFormat.Default)]
        public Decimal[]? Decimals { get; set; }
        [ProtoMember(16, DataFormat = DataFormat.Default)]
        public DateTimeOffsetData[]? DateTimeOffsets { get; set; }
        [ProtoMember(17, DataFormat = DataFormat.Default)]
        public Guid[]? Guids { get; set; }
        [ProtoMember(18, DataFormat = DataFormat.Default)]
        public String?[]? Strings { get; set; }
        [ProtoMember(19, DataFormat = DataFormat.Default)]
        public byte[]?[]? Buffers { get; set; }
        [ProtoMember(20, DataFormat = DataFormat.Default)]
        public QuantityValue[]? Quantities { get; set; }
        [ProtoMember(21, DataFormat = DataFormat.Default)]
        public MyDayOfWeekValue[]? MyDaysOfWeek { get; set; }
        [ProtoMember(22, DataFormat = DataFormat.Default)]
        public MyDateTimeKindValue[]? MyDateTimeKinds { get; set; }

        IEnumerable<Boolean>? IBuiltinTypes.Bools => Bools
            ?.Select(x => x.ToExternal());
        IEnumerable<SByte>? IBuiltinTypes.SBytes => SBytes
            ?.Select(x => x.ToExternal());
        IEnumerable<Byte>? IBuiltinTypes.Bytes => Bytes
            ?.Select(x => x.ToExternal());
        IEnumerable<Int16>? IBuiltinTypes.Shorts => Shorts
            ?.Select(x => x.ToExternal());
        IEnumerable<UInt16>? IBuiltinTypes.UShorts => UShorts
            ?.Select(x => x.ToExternal());
        IEnumerable<Char>? IBuiltinTypes.Chars => Chars
            ?.Select(x => x.ToExternal());
        IEnumerable<Int32>? IBuiltinTypes.Ints => Ints
            ?.Select(x => x.ToExternal());
        IEnumerable<UInt32>? IBuiltinTypes.UInts => UInts
            ?.Select(x => x.ToExternal());
        IEnumerable<Single>? IBuiltinTypes.Floats => Floats
            ?.Select(x => x.ToExternal());
        IEnumerable<Int64>? IBuiltinTypes.Longs => Longs
            ?.Select(x => x.ToExternal());
        IEnumerable<UInt64>? IBuiltinTypes.ULongs => ULongs
            ?.Select(x => x.ToExternal());
        IEnumerable<Double>? IBuiltinTypes.Doubles => Doubles
            ?.Select(x => x.ToExternal());
        IEnumerable<DateTime>? IBuiltinTypes.DateTimes => DateTimes
            ?.Select(x => x.ToExternal());
        IEnumerable<TimeSpan>? IBuiltinTypes.TimeSpans => TimeSpans
            ?.Select(x => x.ToExternal());
        IEnumerable<Decimal>? IBuiltinTypes.Decimals => Decimals
            ?.Select(x => x.ToExternal());
        IEnumerable<DateTimeOffset>? IBuiltinTypes.DateTimeOffsets => DateTimeOffsets
            ?.Select(x => x.ToExternal());
        IEnumerable<Guid>? IBuiltinTypes.Guids => Guids
            ?.Select(x => x.ToExternal());
        IEnumerable<String?>? IBuiltinTypes.Strings => Strings;
        IEnumerable<Octets?>? IBuiltinTypes.Buffers => Buffers?.Select(b => b is null ? null : Octets.UnsafeWrap(b));
        IEnumerable<LabApps.Units.Quantity>? IBuiltinTypes.Quantities => Quantities
            ?.Select(x => x.ToExternal());
        IEnumerable<System.DayOfWeek>? IBuiltinTypes.MyDaysOfWeek => MyDaysOfWeek
            ?.Select(x => x.ToExternal());
        IEnumerable<System.DateTimeKind>? IBuiltinTypes.MyDateTimeKinds => MyDateTimeKinds
            ?.Select(x => x.ToExternal());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public BuiltinTypes()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public BuiltinTypes(IBuiltinTypes source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Bools = source.Bools?.Select(x => x.ToInternal()).ToArray();
            SBytes = source.SBytes?.Select(x => x.ToInternal()).ToArray();
            Bytes = source.Bytes?.Select(x => x.ToInternal()).ToArray();
            Shorts = source.Shorts?.Select(x => x.ToInternal()).ToArray();
            UShorts = source.UShorts?.Select(x => x.ToInternal()).ToArray();
            Chars = source.Chars?.Select(x => x.ToInternal()).ToArray();
            Ints = source.Ints?.Select(x => x.ToInternal()).ToArray();
            UInts = source.UInts?.Select(x => x.ToInternal()).ToArray();
            Floats = source.Floats?.Select(x => x.ToInternal()).ToArray();
            Longs = source.Longs?.Select(x => x.ToInternal()).ToArray();
            ULongs = source.ULongs?.Select(x => x.ToInternal()).ToArray();
            Doubles = source.Doubles?.Select(x => x.ToInternal()).ToArray();
            DateTimes = source.DateTimes?.Select(x => x.ToInternal()).ToArray();
            TimeSpans = source.TimeSpans?.Select(x => x.ToInternal()).ToArray();
            Decimals = source.Decimals?.Select(x => x.ToInternal()).ToArray();
            DateTimeOffsets = source.DateTimeOffsets?.Select(x => x.ToInternal()).ToArray();
            Guids = source.Guids?.Select(x => x.ToInternal()).ToArray();
            Strings = source.Strings?.ToArray();
            Buffers = source.Buffers?.Select(b => b?.Memory.ToArray()).ToArray();
            Quantities = source.Quantities?.Select(x => x.ToInternal()).ToArray();
            MyDaysOfWeek = source.MyDaysOfWeek?.Select(x => x.ToInternal()).ToArray();
            MyDateTimeKinds = source.MyDateTimeKinds?.Select(x => x.ToInternal()).ToArray();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(BuiltinTypes? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Bools.ArrayEquals(other.Bools)) return false;
            if (!SBytes.ArrayEquals(other.SBytes)) return false;
            if (!Bytes.ArrayEquals(other.Bytes)) return false;
            if (!Shorts.ArrayEquals(other.Shorts)) return false;
            if (!UShorts.ArrayEquals(other.UShorts)) return false;
            if (!Chars.ArrayEquals(other.Chars)) return false;
            if (!Ints.ArrayEquals(other.Ints)) return false;
            if (!UInts.ArrayEquals(other.UInts)) return false;
            if (!Floats.ArrayEquals(other.Floats)) return false;
            if (!Longs.ArrayEquals(other.Longs)) return false;
            if (!ULongs.ArrayEquals(other.ULongs)) return false;
            if (!Doubles.ArrayEquals(other.Doubles)) return false;
            if (!DateTimes.ArrayEquals(other.DateTimes)) return false;
            if (!TimeSpans.ArrayEquals(other.TimeSpans)) return false;
            if (!Decimals.ArrayEquals(other.Decimals)) return false;
            if (!DateTimeOffsets.ArrayEquals(other.DateTimeOffsets)) return false;
            if (!Guids.ArrayEquals(other.Guids)) return false;
            if (!Strings.ArrayEquals(other.Strings)) return false;
            if (!Buffers.ArrayEquals(other.Buffers)) return false;
            if (!Quantities.ArrayEquals(other.Quantities)) return false;
            if (!MyDaysOfWeek.ArrayEquals(other.MyDaysOfWeek)) return false;
            if (!MyDateTimeKinds.ArrayEquals(other.MyDateTimeKinds)) return false;
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(BuiltinTypes left, BuiltinTypes right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(BuiltinTypes left, BuiltinTypes right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj)
        {
            return obj is BuiltinTypes other && Equals(other);
        }

        public override int GetHashCode()
        {
            int hash = 0;
            unchecked
            {
                hash = (hash * 397) ^ Bools.CalcHashArray();
                hash = (hash * 397) ^ SBytes.CalcHashArray();
                hash = (hash * 397) ^ Bytes.CalcHashArray();
                hash = (hash * 397) ^ Shorts.CalcHashArray();
                hash = (hash * 397) ^ UShorts.CalcHashArray();
                hash = (hash * 397) ^ Chars.CalcHashArray();
                hash = (hash * 397) ^ Ints.CalcHashArray();
                hash = (hash * 397) ^ UInts.CalcHashArray();
                hash = (hash * 397) ^ Floats.CalcHashArray();
                hash = (hash * 397) ^ Longs.CalcHashArray();
                hash = (hash * 397) ^ ULongs.CalcHashArray();
                hash = (hash * 397) ^ Doubles.CalcHashArray();
                hash = (hash * 397) ^ DateTimes.CalcHashArray();
                hash = (hash * 397) ^ TimeSpans.CalcHashArray();
                hash = (hash * 397) ^ Decimals.CalcHashArray();
                hash = (hash * 397) ^ DateTimeOffsets.CalcHashArray();
                hash = (hash * 397) ^ Guids.CalcHashArray();
                hash = (hash * 397) ^ Strings.CalcHashArray();
                hash = (hash * 397) ^ Buffers.CalcHashArray();
                hash = (hash * 397) ^ Quantities.CalcHashArray();
                hash = (hash * 397) ^ MyDaysOfWeek.CalcHashArray();
                hash = (hash * 397) ^ MyDateTimeKinds.CalcHashArray();
            }
            return hash;
        }

    }


}