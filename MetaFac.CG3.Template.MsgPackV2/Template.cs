//------------------------------------------------------------------------------
//   Warning: This code was automatically generated.
//   Changes to this file may cause incorrect behavior
//   and will be lost when this file is regenerated.
//------------------------------------------------------------------------------
//
// |metacode:version=0.1|
// |metacode:template_begin|
//>>Define("BooleanFieldType","Boolean");
//>>Define("SByteFieldType","SByte");
//>>Define("ByteFieldType","Byte");
//>>Define("Int16FieldType","Int16");
//>>Define("UInt16FieldType","UInt16");
//>>Define("CharFieldType","Char");
//>>Define("Int32FieldType","Int32");
//>>Define("UInt32FieldType","UInt32");
//>>Define("SingleFieldType","Single");
//>>Define("Int64FieldType","Int64");
//>>Define("UInt64FieldType","UInt64");
//>>Define("DoubleFieldType","Double");
//>>Define("DateTimeFieldType","DateTime");
//>>Define("TimeSpanFieldType","TimeSpan");
//>>Define("DateTimeZoneFieldType","DateTimeOffset");
//>>Define("DecimalFieldType","Decimal");
//>>Define("GuidFieldType","Guid");
//>>Define("StringFieldType","String");
//>>Define("BinaryFieldType","byte[]");
//>>Define("ConcreteBoolean","T_BooleanFieldType_");
//>>Define("ConcreteSByte","T_SByteFieldType_");
//>>Define("ConcreteByte","T_ByteFieldType_");
//>>Define("ConcreteInt16","T_Int16FieldType_");
//>>Define("ConcreteUInt16","T_UInt16FieldType_");
//>>Define("ConcreteChar","T_CharFieldType_");
//>>Define("ConcreteInt32","T_Int32FieldType_");
//>>Define("ConcreteUInt32","T_UInt32FieldType_");
//>>Define("ConcreteSingle","T_SingleFieldType_");
//>>Define("ConcreteInt64","T_Int64FieldType_");
//>>Define("ConcreteUInt64","T_UInt64FieldType_");
//>>Define("ConcreteDouble","T_DoubleFieldType_");
//>>Define("ConcreteDateTime","T_DateTimeFieldType_");
//>>Define("ConcreteTimeSpan","T_TimeSpanFieldType_");
//>>Define("ConcreteDateTimeOffset","T_DateTimeZoneFieldType_");
//>>Define("ConcreteDecimal","T_DecimalFieldType_");
//>>Define("ConcreteGuid","T_GuidFieldType_");
//>>Define("ConcreteString","T_StringFieldType_");
//>>Define("ConcreteBinaryFieldType","T_BinaryFieldType_");
//>>Define("ExternalBoolean","T_BooleanFieldType_");
//>>Define("ExternalSByte","T_SByteFieldType_");
//>>Define("ExternalByte","T_ByteFieldType_");
//>>Define("ExternalInt16","T_Int16FieldType_");
//>>Define("ExternalUInt16","T_UInt16FieldType_");
//>>Define("ExternalChar","T_CharFieldType_");
//>>Define("ExternalInt32","T_Int32FieldType_");
//>>Define("ExternalUInt32","T_UInt32FieldType_");
//>>Define("ExternalSingle","T_SingleFieldType_");
//>>Define("ExternalInt64","T_Int64FieldType_");
//>>Define("ExternalUInt64","T_UInt64FieldType_");
//>>Define("ExternalDouble","T_DoubleFieldType_");
//>>Define("ExternalDateTime","T_DateTimeFieldType_");
//>>Define("ExternalTimeSpan","T_TimeSpanFieldType_");
//>>Define("ExternalDateTimeOffset","T_DateTimeZoneFieldType_");
//>>Define("ExternalDecimal","T_DecimalFieldType_");
//>>Define("ExternalGuid","T_GuidFieldType_");
//>>Define("ExternalString","T_StringFieldType_");
//>>Define("ExternalBinaryFieldType","T_BinaryFieldType_");
//>>Define("BinaryFieldType","byte[]");
//>>Define("ConcreteDateTime","DateTimeValue");
//>>Define("ExternalDateTime","DateTime");
//>>Define("ConcreteDateTimeOffset","DateTimeOffsetValue");
//>>Define("ExternalDateTimeOffset","DateTimeOffset");
//>>Define("ConcreteDecimal","DecimalValue");
//>>Define("ExternalDecimal","Decimal");
//>>Define("ConcreteGuid","GuidValue");
//>>Define("ExternalGuid","Guid");
//>>Define("BaseClassName","EntityBase");
#region Auto-generated
//
// Warning: This code was automatically generated. Changes to this file may
// cause incorrect behavior and will be lost when this file is regenerated.
//
// This file was generated by the MetaCode.TS3.CLI tool (or mcts3)
// using a MetaCode generator and modified according to supplied metadata.
//
// Generator: T_GeneratorId_ T_GeneratorVersion_
// Metadata : T_MetadataSource_ T_MetadataVersion_
//
// For more information about using this tool, the help command is:
// mcts3 g2c --help
//
// To download and install the tool, the .NET CLI command is:
// dotnet tool install --global MetaCode.TS3.CLI
//
//--------------------------------------------------------------------------------
#endregion
#nullable enable
using MessagePack;
using MetaCode.Runtime;
using MetaCode.Runtime.MsgPack;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using T_Namespace_.Contracts;

namespace T_Namespace_.MsgPackV2
{
    //>>using (Ignored()) {
    using T_ConcreteOtherType_ = System.Int64;
    using T_ExternalOtherType_ = System.Int64;
    using T_IndexType_ = System.String;
    //>>}

    //>>using (Ignored()) {
    [MessagePackObject]
    public class T_ModelType_ : EntityBase, IT_ModelType_, IEquatable<T_ModelType_>
    {
        public static T_ModelType_? CreateFrom(IT_ModelType_? source)
        {
            if (source is null) return null;
            return new T_ModelType_(source);
        }

        protected override int OnGetEntityTag() => 0;

        [Key(1)]
        public int TestData { get; set; }

        public T_ModelType_() { }
        public T_ModelType_(int testData)
        {
            TestData = testData;
        }
        public T_ModelType_(IT_ModelType_? source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            TestData = source.TestData;
        }
        public bool Equals(T_ModelType_? other)
        {
            if (ReferenceEquals(other, this)) return true;
            if (other is null) return false;
            return other.TestData == TestData;
        }

        public override bool Equals(object? obj)
        {
            return (obj is T_ModelType_ other) && Equals(other);
        }

        public override int GetHashCode()
        {
            return TestData.GetHashCode();
        }
    }

    internal static class ConversionHelpers
    {
        public static T ToExternal<T>(this T value) => value;
        public static T ToInternal<T>(this T value) => value;
    }
    //>>}

    public abstract class EntityBase : IEntityBase, IEquatable<EntityBase>
    {
        public static EntityBase Empty => throw new NotSupportedException();
        public const int ClassTag = 0;
        public EntityBase() { }
        public EntityBase(EntityBase? source) { }
        public EntityBase(IEntityBase? source) { }
        protected abstract int OnGetEntityTag();
        public int GetEntityTag() => OnGetEntityTag();
        public bool Equals(EntityBase? other) => true;
        public override bool Equals(object? obj) => obj is EntityBase other && this.Equals(other);
        public override int GetHashCode() => 0;

        public bool IsFreezable() => false;
        public bool IsFrozen() => false;
        public void Freeze() { }
        public bool TryFreeze() => false;
    }

    //>>using (Ignored()) {
    [MessagePackObject]
    public class T_BaseClassName_ : EntityBase, IT_BaseClassName_, IEquatable<T_BaseClassName_>
    {
        [Key(1)]
        public int BaseClassField1 { get; set; }
        public T_BaseClassName_() { }
        public T_BaseClassName_(T_BaseClassName_? source) : base(source) { }
        public T_BaseClassName_(IT_BaseClassName_? source) : base(source) { }
        public new const int ClassTag = 999;
        protected override int OnGetEntityTag() => ClassTag;
        public bool Equals(T_BaseClassName_? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            return base.Equals(other);
        }
        public override bool Equals(object? obj) => obj is T_BaseClassName_ other && this.Equals(other);
        public override int GetHashCode() => 0;

        private static readonly T_BaseClassName_ _empty = new T_BaseClassName_();
        public static new T_BaseClassName_ Empty => _empty;

    }
    //>>}

    //>>foreach (var cs in outerScope.Iterators["Classes"].Iterations) {
    //>>using (NewScope(cs)) {
    //>>var derivedClasses = cs.Iterators["AllDerivedClasses"].Iterations;
    //>>if (derivedClasses.Count > 0)
    //>>{
    //>>    foreach (var derived in derivedClasses)
    //>>    {
    //>>        using (NewScope(derived)) {
    [Union(T_ClassName_.ClassTag, typeof(T_ClassName_))]
    //>>        }
    //>>    }
    public abstract partial class T_ClassName2_
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T_ClassName_? CreateFrom(IT_ClassName_? source)
        {
            if (source is null) return null;
            int classTag = source.GetEntityTag();
            switch (classTag)
            {
                //>>foreach (var derived in derivedClasses) {
                //>>    using (NewScope(derived)) {
                case T_ClassName_.ClassTag: return T_ClassName_.CreateFrom((IT_ClassName_)source);
                //>>}}
                default:
                    throw new ArgumentOutOfRangeException(nameof(classTag), classTag, null);
            }
        }
    }
    //>>} else {
    public partial class T_ClassName_
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static T_ClassName_? CreateFrom(IT_ClassName_? source)
        {
            if (source is null) return null;
            int classTag = source.GetEntityTag();
            switch (classTag)
            {
                //>>foreach (var derived in derivedClasses)
                //>>{
                //>>    using (NewScope(derived)) {
                case T_ClassName_.ClassTag: return T_ClassName_.CreateFrom((IT_ClassName_)source);
                //>>    }
                //>>}
                default:
                    return new T_ClassName_(source);
            }
        }

        private static readonly T_ClassName_ _empty = new T_ClassName_();
        public static new T_ClassName_ Empty => _empty;

    }
    //>>}
    [MessagePackObject]
    public partial class T_ClassName_ : T_BaseClassName_, IT_ClassName_, IEquatable<T_ClassName_>
    {
        //>>using (Ignored()) {
        private const int T_ClassTag_ = 9000;
        private const int T_FieldTag_ = 100;
        //>>}
        public new const int ClassTag = T_ClassTag_;
        protected override int OnGetEntityTag() => ClassTag;

        //>>foreach (var fs in cs.Iterators["Fields"].Iterations) {
        //>>  using (NewScope(fs)) {
        //>>    var fieldInfo = new FieldInfo(fs, _engine.Current);
        [Key(T_FieldTag_)]
        //>>using (Ignored()) {
        public int IgnoreThisField { get; set; }
        //>>}
        //>>switch (fieldInfo.Kind)
        //>>{
        //>>    case FieldKind.UnaryModel:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 1)]
        //>>}
        public T_ModelType_? T_UnaryModelFieldName_ { get; set; }
        //>>    break; case FieldKind.ArrayModel:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 2)]
        //>>}
        public T_ModelType_?[]? T_ArrayModelFieldName_ { get; set; }
        //>>    break; case FieldKind.IndexModel:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 3)]
        //>>}
        public Dictionary<T_IndexType_, T_ModelType_?>? T_IndexModelFieldName_ { get; set; }
        //>>    break; case FieldKind.UnaryMaybe:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 4)]
        //>>}
        public T_ConcreteOtherType_? T_UnaryMaybeFieldName_ { get; set; }
        //>>    break; case FieldKind.ArrayMaybe:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 5)]
        //>>}
        public T_ConcreteOtherType_?[]? T_ArrayMaybeFieldName_ { get; set; }
        //>>    break; case FieldKind.IndexMaybe:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 6)]
        //>>}
        public Dictionary<T_IndexType_, T_ConcreteOtherType_?>? T_IndexMaybeFieldName_ { get; set; }
        //>>    break; case FieldKind.UnaryOther:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 7)]
        //>>}
        public T_ConcreteOtherType_ T_UnaryOtherFieldName_ { get; set; }
        //>>    break; case FieldKind.ArrayOther:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 8)]
        //>>}
        public T_ConcreteOtherType_[]? T_ArrayOtherFieldName_ { get; set; }
        //>>    break; case FieldKind.IndexOther:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 9)]
        //>>}
        public Dictionary<T_IndexType_, T_ConcreteOtherType_>? T_IndexOtherFieldName_ { get; set; }
        //>>    break; case FieldKind.UnaryBuffer:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 10)]
        //>>}
        public byte[]? T_UnaryBufferFieldName_ { get; set; }
        //>>    break; case FieldKind.ArrayBuffer:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 11)]
        //>>}
        public byte[]?[]? T_ArrayBufferFieldName_ { get; set; }
        //>>    break; case FieldKind.IndexBuffer:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 12)]
        //>>}
        public Dictionary<T_IndexType_, byte[]?>? T_IndexBufferFieldName_ { get; set; }
        //>>    break; case FieldKind.UnaryString:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 13)]
        //>>}
        public String? T_UnaryStringFieldName_ { get; set; }
        //>>    break; case FieldKind.ArrayString:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 14)]
        //>>}
        public String?[]? T_ArrayStringFieldName_ { get; set; }
        //>>    break; case FieldKind.IndexString:
        //>>using (Ignored()) {
        [Key(T_FieldTag_ + 15)]
        //>>}
        public Dictionary<T_IndexType_, String?>? T_IndexStringFieldName_ { get; set; }
        //>>    break; default:
        //>>        throw new ArgumentOutOfRangeException("fieldInfo.Kind", fieldInfo.Kind, $"ordinal={(int)fieldInfo.Kind}");
        //>>}
        //>>}}

        //>>foreach (var fs in cs.Iterators["Fields"].Iterations) {
        //>>  using (NewScope(fs)) {
        //>>    var fieldInfo = new FieldInfo(fs, _engine.Current);
        //>>switch (fieldInfo.Kind)
        //>>{
        //>>    case FieldKind.UnaryModel:
        IT_ModelType_? IT_ClassName_.T_UnaryModelFieldName_ => T_UnaryModelFieldName_;
        //>>    break; case FieldKind.ArrayModel:
        IReadOnlyList<IT_ModelType_?>? IT_ClassName_.T_ArrayModelFieldName_ => T_ArrayModelFieldName_;
        //>>    break; case FieldKind.IndexModel:
        IReadOnlyDictionary<T_IndexType_, IT_ModelType_?>? IT_ClassName_.T_IndexModelFieldName_
            => T_IndexModelFieldName_ is null ? null
            : new DictionaryFacade<T_IndexType_, IT_ModelType_?, T_ModelType_?>(T_IndexModelFieldName_, (x) => x);
        //>>    break; case FieldKind.UnaryMaybe:
        T_ExternalOtherType_? IT_ClassName_.T_UnaryMaybeFieldName_ => T_UnaryMaybeFieldName_.ToExternal();
        //>>    break; case FieldKind.ArrayMaybe:
        IReadOnlyList<T_ExternalOtherType_?>? IT_ClassName_.T_ArrayMaybeFieldName_
            => T_ArrayMaybeFieldName_ is null ? null
            : new ListFacade<T_ExternalOtherType_?, T_ConcreteOtherType_?>(T_ArrayMaybeFieldName_, (x) => x.ToExternal());
        //>>    break; case FieldKind.IndexMaybe:
        IReadOnlyDictionary<T_IndexType_, T_ExternalOtherType_?>? IT_ClassName_.T_IndexMaybeFieldName_
            => T_IndexMaybeFieldName_ is null ? null
            : new DictionaryFacade<T_IndexType_, T_ExternalOtherType_?, T_ConcreteOtherType_?>(T_IndexMaybeFieldName_, (x) => x.ToExternal());
        //>>    break; case FieldKind.UnaryOther:
        T_ExternalOtherType_ IT_ClassName_.T_UnaryOtherFieldName_ => T_UnaryOtherFieldName_.ToExternal();
        //>>    break; case FieldKind.ArrayOther:
        IReadOnlyList<T_ExternalOtherType_>? IT_ClassName_.T_ArrayOtherFieldName_
            => T_ArrayOtherFieldName_ is null ? null
            : new ListFacade<T_ExternalOtherType_, T_ConcreteOtherType_>(T_ArrayOtherFieldName_, (x) => x.ToExternal());
        //>>    break; case FieldKind.IndexOther:
        IReadOnlyDictionary<T_IndexType_, T_ExternalOtherType_>? IT_ClassName_.T_IndexOtherFieldName_
            => T_IndexOtherFieldName_ is null ? null
            : new DictionaryFacade<T_IndexType_, T_ExternalOtherType_, T_ConcreteOtherType_>(T_IndexOtherFieldName_, (x) => x.ToExternal());
        //>>    break; case FieldKind.UnaryBuffer:
        ReadOnlyMemory<byte> IT_ClassName_.T_UnaryBufferFieldName_ => T_UnaryBufferFieldName_;
        //>>    break; case FieldKind.ArrayBuffer:
        IReadOnlyList<ReadOnlyMemory<byte>>? IT_ClassName_.T_ArrayBufferFieldName_
            => T_ArrayBufferFieldName_ is null ? null
            : new ListFacade<ReadOnlyMemory<byte>, byte[]?>(T_ArrayBufferFieldName_, (x) => x);
        //>>    break; case FieldKind.IndexBuffer:
        IReadOnlyDictionary<T_IndexType_, ReadOnlyMemory<byte>>? IT_ClassName_.T_IndexBufferFieldName_
            => T_IndexBufferFieldName_ is null ? null
            : new DictionaryFacade<T_IndexType_, ReadOnlyMemory<byte>, byte[]?>(T_IndexBufferFieldName_, (x) => x);
        //>>    break; case FieldKind.UnaryString:
        String? IT_ClassName_.T_UnaryStringFieldName_ => T_UnaryStringFieldName_;
        //>>    break; case FieldKind.ArrayString:
        IReadOnlyList<String?>? IT_ClassName_.T_ArrayStringFieldName_ => T_ArrayStringFieldName_;
        //>>    break; case FieldKind.IndexString:
        IReadOnlyDictionary<T_IndexType_, String?>? IT_ClassName_.T_IndexStringFieldName_ => T_IndexStringFieldName_;
        //>>    break; default: break;
        //>>}
        //>>}}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T_ClassName_()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T_ClassName_(IT_ClassName_? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            //>>foreach (var fs in cs.Iterators["Fields"].Iterations) {
            //>>  using (NewScope(fs)) {
            //>>    var fieldInfo = new FieldInfo(fs, _engine.Current);
            //>>switch (fieldInfo.Kind)
            //>>{
            //>>    case FieldKind.UnaryModel:
            T_UnaryModelFieldName_ = T_ModelType_.CreateFrom(source.T_UnaryModelFieldName_);
            //>>    break; case FieldKind.ArrayModel:
            T_ArrayModelFieldName_ = source.T_ArrayModelFieldName_?.Select(x => T_ModelType_.CreateFrom(x)).ToArray();
            //>>    break; case FieldKind.IndexModel:
            T_IndexModelFieldName_ = source.T_IndexModelFieldName_?.ToDictionary(kvp => kvp.Key, kvp => T_ModelType_.CreateFrom(kvp.Value));
            //>>    break; case FieldKind.UnaryMaybe:
            T_UnaryMaybeFieldName_ = source.T_UnaryMaybeFieldName_.ToInternal();
            //>>    break; case FieldKind.ArrayMaybe:
            T_ArrayMaybeFieldName_ = source.T_ArrayMaybeFieldName_?.Select(x => x.ToInternal()).ToArray();
            //>>    break; case FieldKind.IndexMaybe:
            T_IndexMaybeFieldName_ = source.T_IndexMaybeFieldName_?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToInternal());
            //>>    break; case FieldKind.UnaryOther:
            T_UnaryOtherFieldName_ = source.T_UnaryOtherFieldName_.ToInternal();
            //>>    break; case FieldKind.ArrayOther:
            T_ArrayOtherFieldName_ = source.T_ArrayOtherFieldName_?.Select(x => x.ToInternal()).ToArray();
            //>>    break; case FieldKind.IndexOther:
            T_IndexOtherFieldName_ = source.T_IndexOtherFieldName_?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToInternal());
            //>>    break; case FieldKind.UnaryBuffer:
            T_UnaryBufferFieldName_ = source.T_UnaryBufferFieldName_.IsEmpty ? null : source.T_UnaryBufferFieldName_.ToArray();
            //>>    break; case FieldKind.ArrayBuffer:
            T_ArrayBufferFieldName_ = source.T_ArrayBufferFieldName_?.Select(b => b.IsEmpty ? null : b.ToArray()).ToArray();
            //>>    break; case FieldKind.IndexBuffer:
            T_IndexBufferFieldName_ = source.T_IndexBufferFieldName_?.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.IsEmpty ? null : kvp.Value.ToArray());
            //>>    break; case FieldKind.UnaryString:
            T_UnaryStringFieldName_ = source.T_UnaryStringFieldName_;
            //>>    break; case FieldKind.ArrayString:
            T_ArrayStringFieldName_ = source.T_ArrayStringFieldName_?.ToArray();
            //>>    break; case FieldKind.IndexString:
            T_IndexStringFieldName_ = source.T_IndexStringFieldName_?.ToDictionary(kvp => kvp.Key, kvp => (String?)kvp.Value);
            //>>    break; default: break;
            //>>}
            //>>}}
        }

        public bool Equals(T_ClassName_? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            //>>foreach (var fs in cs.Iterators["Fields"].Iterations) {
            //>>  using (NewScope(fs)) {
            //>>    var fieldInfo = new FieldInfo(fs, _engine.Current);
            //>>switch (fieldInfo.Kind)
            //>>{
            //>>    case FieldKind.UnaryModel:
            if (!T_UnaryModelFieldName_.ValueEquals(other.T_UnaryModelFieldName_)) return false;
            //>>    break; case FieldKind.ArrayModel:
            if (!T_ArrayModelFieldName_.ArrayEquals(other.T_ArrayModelFieldName_)) return false;
            //>>    break; case FieldKind.IndexModel:
            if (!T_IndexModelFieldName_.IndexEquals(other.T_IndexModelFieldName_)) return false;
            //>>    break; case FieldKind.UnaryMaybe:
            if (!T_UnaryMaybeFieldName_.ValueEquals(other.T_UnaryMaybeFieldName_)) return false;
            //>>    break; case FieldKind.ArrayMaybe:
            if (!T_ArrayMaybeFieldName_.ArrayEquals(other.T_ArrayMaybeFieldName_)) return false;
            //>>    break; case FieldKind.IndexMaybe:
            if (!T_IndexMaybeFieldName_.IndexEquals(other.T_IndexMaybeFieldName_)) return false;
            //>>    break; case FieldKind.UnaryOther:
            if (!T_UnaryOtherFieldName_.ValueEquals(other.T_UnaryOtherFieldName_)) return false;
            //>>    break; case FieldKind.ArrayOther:
            if (!T_ArrayOtherFieldName_.ArrayEquals(other.T_ArrayOtherFieldName_)) return false;
            //>>    break; case FieldKind.IndexOther:
            if (!T_IndexOtherFieldName_.IndexEquals(other.T_IndexOtherFieldName_)) return false;
            //>>    break; case FieldKind.UnaryBuffer:
            if (!T_UnaryBufferFieldName_.ValueEquals(other.T_UnaryBufferFieldName_)) return false;
            //>>    break; case FieldKind.ArrayBuffer:
            if (!T_ArrayBufferFieldName_.ArrayEquals(other.T_ArrayBufferFieldName_)) return false;
            //>>    break; case FieldKind.IndexBuffer:
            if (!T_IndexBufferFieldName_.IndexEquals(other.T_IndexBufferFieldName_)) return false;
            //>>    break; case FieldKind.UnaryString:
            if (!T_UnaryStringFieldName_.ValueEquals(other.T_UnaryStringFieldName_)) return false;
            //>>    break; case FieldKind.ArrayString:
            if (!T_ArrayStringFieldName_.ArrayEquals(other.T_ArrayStringFieldName_)) return false;
            //>>    break; case FieldKind.IndexString:
            if (!T_IndexStringFieldName_.IndexEquals(other.T_IndexStringFieldName_)) return false;
            //>>    break; default: break;
            //>>}
            //>>}}
            return base.Equals(other);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(T_ClassName_ left, T_ClassName_ right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(T_ClassName_ left, T_ClassName_ right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj)
        {
            return obj is T_ClassName_ other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            //>>foreach (var fs in cs.Iterators["Fields"].Iterations) {
            //>>  using (NewScope(fs)) {
            //>>    var fieldInfo = new FieldInfo(fs, _engine.Current);
            //>>switch (fieldInfo.Kind)
            //>>{
            //>>    case FieldKind.UnaryModel:
            hc.Add(T_UnaryModelFieldName_.CalcHashUnary());
            //>>    break; case FieldKind.ArrayModel:
            hc.Add(T_ArrayModelFieldName_.CalcHashArray());
            //>>    break; case FieldKind.IndexModel:
            hc.Add(T_IndexModelFieldName_.CalcHashIndex());
            //>>    break; case FieldKind.UnaryMaybe:
            hc.Add(T_UnaryMaybeFieldName_.CalcHashUnary());
            //>>    break; case FieldKind.ArrayMaybe:
            hc.Add(T_ArrayMaybeFieldName_.CalcHashArray());
            //>>    break; case FieldKind.IndexMaybe:
            hc.Add(T_IndexMaybeFieldName_.CalcHashIndex());
            //>>    break; case FieldKind.UnaryOther:
            hc.Add(T_UnaryOtherFieldName_.CalcHashUnary());
            //>>    break; case FieldKind.ArrayOther:
            hc.Add(T_ArrayOtherFieldName_.CalcHashArray());
            //>>    break; case FieldKind.IndexOther:
            hc.Add(T_IndexOtherFieldName_.CalcHashIndex());
            //>>    break; case FieldKind.UnaryBuffer:
            hc.Add(T_UnaryBufferFieldName_.CalcHashUnary());
            //>>    break; case FieldKind.ArrayBuffer:
            hc.Add(T_ArrayBufferFieldName_.CalcHashArray());
            //>>    break; case FieldKind.IndexBuffer:
            hc.Add(T_IndexBufferFieldName_.CalcHashIndex());
            //>>    break; case FieldKind.UnaryString:
            hc.Add(T_UnaryStringFieldName_.CalcHashUnary());
            //>>    break; case FieldKind.ArrayString:
            hc.Add(T_ArrayStringFieldName_.CalcHashArray());
            //>>    break; case FieldKind.IndexString:
            hc.Add(T_IndexStringFieldName_.CalcHashIndex());
            //>>    break; default: break;
            //>>}
            //>>}}
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    //>>}}

}
// |metacode:template_end|
